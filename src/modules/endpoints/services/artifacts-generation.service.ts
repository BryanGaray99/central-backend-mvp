import { Injectable, Logger } from '@nestjs/common';
import { FileSystemService } from '../../projects/services/file-system.service';
import { TemplateService } from '../../projects/services/template.service';
import { Project } from '../../projects/project.entity';
import { RegisterEndpointDto } from '../dto/register-endpoint.dto';
import * as path from 'path';

@Injectable()
export class ArtifactsGenerationService {
  private readonly logger = new Logger(ArtifactsGenerationService.name);
  private readonly templatesPath = path.join(__dirname, '..', 'templates');

  constructor(
    private readonly fileSystemService: FileSystemService,
    private readonly templateService: TemplateService,
  ) {}

  async generate(project: Project, dto: RegisterEndpointDto, analysisResult: any) {
    this.logger.log(`Starting artifacts generation for ${dto.entityName}`);

    const basePath = project.path;
    const sectionPath = dto.section;
    const entityFileName = this.kebabCase(dto.entityName);
    
    // Create necessary directories
    const fixturesDir = path.join(basePath, 'src', 'fixtures', sectionPath);
    await this.fileSystemService.createDirectory(fixturesDir);
    const schemasDir = path.join(basePath, 'src', 'schemas', sectionPath);
    await this.fileSystemService.createDirectory(schemasDir);
    const featuresDir = path.join(basePath, 'src', 'features', sectionPath);
    await this.fileSystemService.createDirectory(featuresDir);
    const stepsDir = path.join(basePath, 'src', 'steps', sectionPath);
    await this.fileSystemService.createDirectory(stepsDir);
    const typesDir = path.join(basePath, 'src', 'types', sectionPath);
    await this.fileSystemService.createDirectory(typesDir);

    // Generate each artifact
    await this.generateSchemaFile(schemasDir, entityFileName, analysisResult.inferredResponseSchema);
    await this.generateFeatureFile(featuresDir, entityFileName, dto, analysisResult);
    await this.generateStepsFile(stepsDir, entityFileName, dto, analysisResult);
    await this.generateFixtureFile(fixturesDir, entityFileName, dto);
    await this.generateTypesFile(typesDir, entityFileName, dto, analysisResult.inferredResponseSchema);
    
    this.logger.log('Artifacts generation completed.');
  }

  private kebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/[\s_]+/g, '-')
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '');
  }

  private async generateSchemaFile(dir: string, fileName: string, schema: any) {
    const filePath = path.join(dir, `${fileName}.schema.ts`);
    const schemaContent = `export const ${fileName}Schema = ${JSON.stringify(schema, null, 2)};`;
    
    const content = `// Generated by the auto-generation engine\n\n${schemaContent}\n`;

    await this.fileSystemService.writeFile(filePath, content);
    this.logger.log(`Schema file generated at: ${filePath}`);
  }

  private async generateFeatureFile(dir: string, fileName: string, dto: RegisterEndpointDto, analysisResult: any) {
    const filePath = path.join(dir, `${fileName}.feature`);
    const templatePath = path.join(this.templatesPath, 'feature.template');

    const variables = {
      entityName: dto.entityName,
      entityNameLowerCase: dto.entityName.toLowerCase(),
      path: dto.path,
      method: dto.method,
      inferredStatusCode: analysisResult.inferredStatusCode,
    };

    await this.templateService.writeRenderedTemplate(templatePath, filePath, variables);
    this.logger.log(`Feature file generated at: ${filePath}`);
  }

  private async generateStepsFile(dir: string, fileName: string, dto: RegisterEndpointDto, analysisResult: any) {
    const filePath = path.join(dir, `${fileName}.steps.ts`);
    const templatePath = path.join(this.templatesPath, 'steps.template');

    const variables = {
      entityName: dto.entityName,
      path: dto.path,
      method: dto.method,
      methodLC: dto.method.toLowerCase(),
      inferredStatusCode: analysisResult.inferredStatusCode,
    };

    await this.templateService.writeRenderedTemplate(templatePath, filePath, variables);
    this.logger.log(`Steps file generated at: ${filePath}`);
  }

  private async generateFixtureFile(dir: string, fileName: string, dto: RegisterEndpointDto) {
    const filePath = path.join(dir, `${fileName}.fixture.ts`);
    const templatePath = path.join(this.templatesPath, 'fixture.template');

    // Fixture only makes sense if there's a request body
    const fields = dto.requestBodyDefinition?.map(field => ({
      ...field,
      example: this.formatExample(field.type, field.example),
    })) ?? [];

    const variables = {
      entityName: dto.entityName,
      entityNameLC: dto.entityName.toLowerCase(),
      section: dto.section,
      fields,
    };

    await this.templateService.writeRenderedTemplate(templatePath, filePath, variables);
    this.logger.log(`Fixture file generated at: ${filePath}`);
  }

  private async generateTypesFile(dir: string, fileName: string, dto: RegisterEndpointDto, schema: any) {
    const filePath = path.join(dir, `${fileName}.ts`);
    const templatePath = path.join(this.templatesPath, 'types.template');

    const requestBodyFields = dto.requestBodyDefinition?.map(f => ({ name: f.name, type: f.type })) ?? [];
    
    const responseFields = Object.keys(schema.properties || {}).map(key => ({
      name: key,
      type: schema.properties[key].type,
    }));

    const variables = {
      entityName: dto.entityName,
      requestBodyFields,
      responseFields,
    };

    await this.templateService.writeRenderedTemplate(templatePath, filePath, variables);
    this.logger.log(`Types file generated at: ${filePath}`);
  }

  private formatExample(type: string, example: any): string {
    if (example === undefined) {
      // Return a helper function call if no example
      return `${type}()`;
    }
    if (type === 'string') {
      return `'${example}'`;
    }
    return String(example);
  }
} 